include "cowgol.coh";
include "argv.coh";
include "file.coh";
include "strings.coh";
include "malloc.coh";

typedef Arith is uint32;

include "types.coh";
include "arch68000.tokens.coh";

# These are the internal addressing mode encodings.
const AM_REGD    := 0b000000;
const AM_REGA    := 0b001000;
const AM_IND     := 0b010000;
const AM_POSTINC := 0b011000;
const AM_PREDEC  := 0b100000;
const AM_ADISP   := 0b101000;
#const AM_AINDEX  := 0b110000; # extension
const AM_ABSW    := 0b111000;
const AM_ABSL    := 0b111001;
const AM_PCDISP  := 0b111010;
#const AM_PCINDEX := 0b111011; # extension
const AM_IMM     := 0b111100;

const AM_CCR     := 0x80;
const AM_SR      := 0x81;

sub IsRvalue(am: uint8): (r: uint8) is
	r := 1;
	if am >= AM_PCDISP then
		r := 0;
	end if;
end sub;

sub IsRvalueD(am: uint8): (r: uint8) is
	if am == AM_REGA then
		r := 0;
	else
		am := IsRvalue(am);
	end if;
end sub;

sub IsLvalue(am: uint8): (r: uint8) is
	r := 1;
	if am >= AM_IMM then
		r := 0;
	end if;
end sub;

sub IsLvalueD(am: uint8): (r: uint8) is
	if am == AM_REGA then
		r := 0;
	else
		am := IsLvalue(am);
	end if;
end sub;

sub IsLvalueM(am: uint8): (r: uint8) is
	if am <= AM_REGA then
		r := 0;
	else
		am := IsLvalue(am);
	end if;
end sub;

record AddressingMode is
	mode: uint8;
	reg: uint8;
	xreg: uint8;
	value: Number;
end record;

var keywords: Keyword[] := {
	# --- Special pseudo-instructions ------------------------------------

	{ ".org",    INSN_ORG,     0 },
	{ ".seg",    INSN_SEGMENT, 0 },
	{ ".db",     INSN_DB,      0 },
	{ ".dw",     INSN_DW,      0 },
	{ ".dd",     INSN_DD,      0 },

	# --- Registers and modifiers ----------------------------------------

	{ "d0",		 REG_D,        0 },
	{ "d1",		 REG_D,        1 },
	{ "d2",		 REG_D,        2 },
	{ "d3",		 REG_D,        3 },
	{ "d4",		 REG_D,        4 },
	{ "d5",		 REG_D,        5 },
	{ "d6",		 REG_D,        6 },
	{ "d7",		 REG_D,        7 },
	{ "a0",		 REG_A,        0 },
	{ "a1",		 REG_A,        1 },
	{ "a2",		 REG_A,        2 },
	{ "a3",		 REG_A,        3 },
	{ "a4",		 REG_A,        4 },
	{ "a5",		 REG_A,        5 },
	{ "a6",		 REG_A,        6 },
	{ "a7",		 REG_A,        7 },

	{ "pc",      REG_PC,       0 },
	{ "ccr",     REG_CCRSR,    0 },
	{ "sr",      REG_CCRSR,    1 },

	{ ".b",      REG_MOD,      0 },
	{ ".w",      REG_MOD,      1 },
	{ ".l",      REG_MOD,      2 },

	# --- Instructions ---------------------------------------------------

	# dX,dY or -(aX),-(aY) only

	{ "abcd",    INSN_ABCD,    0b1100000100000000 },
	{ "sbcd",    INSN_ABCD,    0b1000000100000000 },

	# dX,dY or -(aX),-(aY) with size mod

	{ "addx",    INSN_ADDX,    0b1101000100000000 },
	{ "subx",    INSN_ADDX,    0b1001000100000000 },

	# add, addq, adda, addi and friends

	{ "add",     INSN_ADDSUB,  0 },
	{ "addq",    INSN_ADDSUB,  0 },
	{ "adda",    INSN_ADDSUB,  0 },
	{ "addi",    INSN_ADDSUB,  0 },

	{ "sub",     INSN_ADDSUB,  1 },
	{ "subq",    INSN_ADDSUB,  1 },
	{ "suba",    INSN_ADDSUB,  1 },
	{ "subi",    INSN_ADDSUB,  1 },

	{ "and",     INSN_ADDSUB,  2 },
	{ "andi",    INSN_ADDSUB,  2 },
	{ "or",      INSN_ADDSUB,  3 },
	{ "ori",     INSN_ADDSUB,  3 },

	{ "eor",     INSN_ADDSUB,  4 },
	{ "eori",    INSN_ADDSUB,  4 },

	# Shifts

	{ "asr",     INSN_ASL,     0b000 },
	{ "asl",     INSN_ASL,     0b001 },
	{ "lsr",     INSN_ASL,     0b010 },
	{ "lsl",     INSN_ASL,     0b011 },
	{ "roxr",    INSN_ASL,     0b100 },
	{ "roxl",    INSN_ASL,     0b101 },
	{ "ror",     INSN_ASL,     0b110 },
	{ "rol",     INSN_ASL,     0b111 },
	
	# Branches

	{ "bra",     INSN_BRA,     0x0 },
	{ "bsr",     INSN_BRA,     0x1 },
	{ "bhi",     INSN_BRA,     0x2 },
	{ "bls",     INSN_BRA,     0x3 },
	{ "bcc",     INSN_BRA,     0x4 },
	{ "bcs",     INSN_BRA,     0x5 },
	{ "bne",     INSN_BRA,     0x6 },
	{ "beq",     INSN_BRA,     0x7 },
	{ "bvc",     INSN_BRA,     0x8 },
	{ "bvs",     INSN_BRA,     0x9 },
	{ "bpl",     INSN_BRA,     0xa },
	{ "bmi",     INSN_BRA,     0xb },
	{ "bge",     INSN_BRA,     0xc },
	{ "blt",     INSN_BRA,     0xd },

};

include "lexer.coh";
include "emitter.coh";
include "symbols.coh";

sub MustBeRawNumber(type: uint8) is
	if type != AS_NUMBER then
		SimpleError("only raw numbers are allowed as displacements");
	end if;
end sub;

sub DisplacementOutOfRange(disp: uint32, max: uint32) is
	if disp > max then
		SimpleError("displacement out of range");
	end if;
end sub;

sub InvalidOperand() is
	SimpleError("invalid operand");
end sub;

sub Emit16(w: uint16) is
	Emit8((w >> 8) as uint8);
	Emit8(w as uint8);
end sub;

sub Emit32(n: [Number]) is
	var d := n.number;
	Emit16((d >> 16) as uint16);
	Emit16(d as uint16);
end sub;

sub EmitX(ea: [AddressingMode], size: uint8) is
	case ea.mode is
		when AM_ADISP:
			MustBeRawNumber(ea.value.type);
			Emit16(ea.value.number as uint16);

		#when AM_AINDEX:
		#	MustBeRawNumber(ea.value.type);
		#	DisplacementOutOfRange(ea.value.number, 0xff);
		#	var m: uint16 := 0;
		#	if size == 0 then
		#		InvalidOperand();
		#	elseif size == 2 then
		#		m := 1;
		#	end if;

		#	Emit16((ea.value.number as uint16)
		#		| (ea.xreg as uint16 << 12)
		#		| (m << 11));

		when AM_ABSW:
			MustBeRawNumber(ea.value.type);
			if (ea.value.type > 0x7fff) and (ea.value.type < 0xffff8000) then
				SimpleError("absolute word address out of range");
			end if;
			Emit16(ea.value.number as uint16);

		when AM_ABSL:
			Emit32(&ea.value);

		when AM_IMM:
			if size == 2 then
				Emit32(&ea.value);
			else
				MustBeRawNumber(ea.value.type);
				Emit16(ea.value.number as uint16);
			end if;

		when AM_PCDISP:
			MustBeRawNumber(ea.value.type);
			Emit16(ea.value.number as uint16);
	end case;
end sub;

include "arch68000.parser.coh";
include "cowasm2.coh";

Main("68000 family assembler (c) 2021 David Given");


