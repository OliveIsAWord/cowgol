%token EOS NUMBER STRING ID.
%token PERCENT OPENPAREN CLOSEPAREN OPENSQ CLOSESQ.
%token COLON PLUS SLASH STAR MINUS.
%token PIPE CARET COMMA AMPERSAND LSHIFT RSHIFT.
%token OPENBR CLOSEBR TILDE LEOP LTOP GEOP GTOP.
%token EQOP NEOP HASH AT.

%left COMMA.
%left AMPERSAND.
%left PIPE.
%left CARET.
%nonassoc LTOP LEOP GTOP GEOP EQOP NEOP.
%left LSHIFT RSHIFT.
%left PLUS MINUS.
%left STAR SLASH PERCENT.
%right NOT TILDE.

%token_type {Token}

%syntax_error
{
        StartError();
        print("unexpected ");
        print(yyTokenName[yymajor]);
        EndError();
}

%stack_size 100
%stack_overflow
{
        StartError();
        print("parser stack overflow");
        EndError();
}

%token_destructor
{
        if (yymajor == STRING) or (yymajor == ID) then
                print("free unused string\n");
                Free($$.string as [uint8]);
        end if;
}

program ::= statements.

statements ::= /* empty */.
statements ::= statements statement.

statement ::= label instruction EOS.

instruction ::= /* empty */.

instruction ::= INSN_ORG expression(E).
	{ [currentProgramCounter] := E.number; }

instruction ::= INSN_SEGMENT expression(E).
	{
		currentSegment := E.number as uint8;
		if currentSegment >= @sizeof programCounter then
			SimpleError("segment out of range");
		end if;
		currentProgramCounter := &programCounter[currentSegment];
	}

statement ::= ID(I) EQUALS expression(E) EOS.
	{ SetSymbol(I.string, E.number, E.type); }

/* --- Expressions ------------------------------------------------------- */

%type expression {Number}

%include
{
	sub CheckNumber(space: uint8) is
		if space != AS_NUMBER then
			SimpleError("must use a simple number here");
		end if;
	end sub;

	sub SimpleComputation(e: [Number], e1: [Number], e2: [Number], v: Arith) is
		CheckNumber(e1.type);
		CheckNumber(e2.type);
		e.number := v;
		e.type := AS_NUMBER;
	end sub;
}

expression(E) ::= NUMBER(T).
	{ E.number := T.number; E.type := AS_NUMBER; }

expression(E) ::= ID(I).
	{ var s := FindSymbol(I.string); E.number := s.number; E.type := s.type; }

expression(E) ::= OPENPAREN expression(E1) CLOSEPAREN.
	{ E.number := E1.number; E.type := E1.type; }

expression(E) ::= MINUS expression(E1).
	{ CheckNumber(E1.type); E.number := -E1.number; E.type := AS_NUMBER; }

expression(E) ::= PLUS expression(E1).
	{ CheckNumber(E1.type); E.number := E1.number; E.type := AS_NUMBER; }

expression(E) ::= TILDE expression(E1).
	{ CheckNumber(E1.type); E.number := ~E1.number; E.type := AS_NUMBER; }

expression(E) ::= expression(E1) AMPERSAND expression(E2).
	{ SimpleComputation(&E, &E1, &E2, E1.number & E2.number); }

expression(E) ::= expression(E1) CARET expression(E2).
	{ SimpleComputation(&E, &E1, &E2, E1.number ^ E2.number); }

expression(E) ::= expression(E1) PIPE expression(E2).
	{ SimpleComputation(&E, &E1, &E2, E1.number | E2.number); }

expression(E) ::= expression(E1) STAR expression(E2).
	{ SimpleComputation(&E, &E1, &E2, E1.number * E2.number); }

expression(E) ::= expression(E1) SLASH expression(E2).
	{ SimpleComputation(&E, &E1, &E2, E1.number / E2.number); }

expression(E) ::= expression(E1) PERCENT expression(E2).
	{ SimpleComputation(&E, &E1, &E2, E1.number % E2.number); }

expression(E) ::= expression(E1) LSHIFT expression(E2).
	{ SimpleComputation(&E, &E1, &E2, E1.number << (E2.number as uint8)); }

expression(E) ::= expression(E1) RSHIFT expression(E2).
	{ SimpleComputation(&E, &E1, &E2, E1.number >> (E2.number as uint8)); }

expression(E) ::= expression(E1) MINUS expression(E2).
	{
		if E2.type == AS_NUMBER then
			E.number := E1.number - E2.number;
			E.type := E1.type;
		elseif E1.type == E2.type then
			E.number := E1.number - E2.number;
			E.type := AS_NUMBER;
		else
			SimpleError("incompatible number types");
		end if;
	}

expression(E) ::= expression(E1) PLUS expression(E2).
	{
		if E2.type == AS_NUMBER then
			E.number := E1.number + E2.number;
			E.type := E1.type;
		else
			SimpleError("incompatible number types");
		end if;
	}

