%{
	sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size) is
		newvalue := value;
	end sub;

	sub E_symref(sym: [Symbol], off: Size) is
		if sym.wsid == WSID_STATIC then
			E_wsref(sym.subr.id, sym.wsid, sym.off);
			if off != 0 then
                E("+0x");
				E_u16(off as uint16);
			end if;
		else
			E_wsref(sym.subr.id, sym.wsid, sym.off + off);
		end if;
	end sub;

	sub R_flushall() is
		RegCacheFlush(ALL_REGS);
	end sub;

	sub R_flush(reg: RegId) is
		RegCacheFlush(FindConflictingRegisters(reg));
	end sub;

	sub AllocPLabel(): (lid: uint16) is
		# Cheap and cheerful way to allocate a label which won't overlap the
		# frontend's numbering.
		lid := -AllocLabel();
	end sub;

	sub E_label(label: LabelRef) is
		R_flushall();
		E_labelref(label);
		E(":\n");
	end sub;

	sub E_insn(insn: string) is
		E_tab();
		E(insn);
		E_space();
	end sub;

	sub E_insn_simple(insn: string) is
		E_tab();
		E(insn);
		E_nl();
	end sub;

	sub E_const() is
		E("#");
	end sub;

	sub E_db() is E_insn("db"); end sub;
	sub E_dw() is E_insn("dw"); end sub;

	sub E_jump(insn: string, label: LabelRef) is
		R_flushall();
		E_insn(insn);
		E_labelref(label);
		E_nl();
	end sub;

	sub E_jmp(label: LabelRef) is E_jump("sjmp", label); end sub;

    sub E_jumps_with_fallthrough(trueinsn: string, falseinsn: string, node: [Node]) is
        if node.beq.truelabel != node.beq.fallthrough then
            E_jump(trueinsn, node.beq.truelabel);
        end if;
        if node.beq.falselabel != node.beq.fallthrough then
            E_jump(falseinsn, node.beq.falselabel);
        end if;
    end sub;

    sub E_reg(reg: RegId) is
        case reg is
            when REG_A:    E("a"); return;
            when REG_DPTR: E("dptr"); return;
            when REG_R0:   E("r0"); return;
            when REG_R1:   E("r1"); return;
            when REG_R2:   E("r2"); return;
            when REG_R3:   E("r3"); return;
            when REG_R4:   E("r4"); return;
            when REG_R5:   E("r5"); return;
            when REG_R6:   E("r6"); return;
            when REG_R7:   E("r7"); return;
            when REG_R0R1: E("r0r1"); return;
            when REG_R2R3: E("r2r3"); return;
            when REG_R4R5: E("r4r5"); return;
            when REG_R6R7: E("r6r7"); return;
        end case;
    end sub;

    sub reglo(reg: RegId): (oreg: RegId) is
        case reg is
            when REG_R0R1: oreg := REG_R1;
            when REG_R2R3: oreg := REG_R3;
            when REG_R4R5: oreg := REG_R5;
            when REG_R6R7: oreg := REG_R7;
            when REG_R0R1R2R3: oreg := REG_R2R3;
            when REG_R4R5R6R7: oreg := REG_R6R7;
            when else: SimpleError("bad reglo");
        end case;
    end sub;

    sub reghi(reg: RegId): (oreg: RegId) is
        case reg is
            when REG_R0R1: oreg := REG_R0;
            when REG_R2R3: oreg := REG_R2;
            when REG_R4R5: oreg := REG_R4;
            when REG_R6R7: oreg := REG_R6;
            when REG_R0R1R2R3: oreg := REG_R0R1;
            when REG_R4R5R6R7: oreg := REG_R4R5;
            when else: SimpleError("bad reghi");
        end case;
    end sub;

    sub E_reglo(reg: RegId) is
        E_reg(reglo(reg));
    end sub;

    sub E_reghi(reg: RegId) is
        E_reg(reghi(reg));
    end sub;

    sub E_regi(reg: RegId) is
        E("@");
        E_reg(reg);
    end sub;

    sub E_mov8(dest: RegId, src: RegId) is
        E_insn("mov");
        E_reg(dest);
        E_comma();
        E_reg(src);
        E_nl();
    end sub;

    sub E_mov16(dest: RegId, src: RegId) is
        E_insn("mov16");
        E_reg(dest);
        E_comma();
        E_reg(src);
        E_nl();
    end sub;
        
    sub E_mov32(dest: RegId, src: RegId) is
        E_mov16(reglo(dest), reglo(src));
        E_mov16(reghi(dest), reghi(src));
    end sub;

    sub E_callhelper(name: string) is
        var helper := GetHelper(name);
        R_flushall();
        E_insn("call");
        E_b8(COO_ESCAPE_SUBREF);
        E_b16(helper.id);
        E_nl();
    end sub;
        
    sub ArchBeginComment() is
        E("\t\\ ");
    end sub;

    sub ArchEndComment() is
        E_nl();
    end sub;

	# Note that this *destroys* the source register.
	sub ArchEmitMove(src: RegId, dest: RegId) is
        if src == 0 then
            E_insn("pop");
            E_reg(dest);
            E_nl();
        elseif dest == 0 then
            E_insn("push");
            E_reg(src);
            E_nl();
        elseif (src & (REG_A|REGCLASS_R8)) != 0 then
            E_mov8(dest, src);
        elseif (src & REGCLASS_R16) != 0 then
            E_mov16(dest, src);
        elseif (src & REGCLASS_R32) != 0 then
            E_mov32(dest, src);
        else
            R_flush(dest);
            StartError();
            print("bad move: ");
            print_hex_i32(src);
            print(" -> ");
            print_hex_i32(dest);
            EndError();
        end if;
	end sub;

	sub ArchEndInstruction() is
	end sub;

	sub ArchEndGroup() is
	end sub;
%}

wordsize uint16;

register a;
register dptr;
register r0 r1 r2 r3 r4 r5 r6 r7;
register r0r1 r2r3 r4r5 r6r7;
register r0r1r2r3 r4r5r6r7;

regclass r8 := r0|r1|r2|r3|r4|r5|r6|r7;
regclass r16 := r0r1|r2r3|r4r5|r6r7;
regclass r32 := r0r1r2r3|r4r5r6r7;

regdata a          compatible r8;
regdata dptr       compatible r16;
regdata r0         compatible r8|a;
regdata r1         compatible r8|a;
regdata r2         compatible r8|a;
regdata r3         compatible r8|a;
regdata r4         compatible r8|a;
regdata r5         compatible r8|a;
regdata r6         compatible r8|a;
regdata r7         compatible r8|a;
regdata r0r1 uses r0|r1|r0r1r2r3 compatible r16|dptr;
regdata r2r3 uses r2|r3|r0r1r2r3 compatible r16|dptr;
regdata r4r5 uses r4|r5|r4r5r6r7 compatible r16|dptr;
regdata r6r7 uses r6|r7|r4r5r6r7 compatible r16|dptr;
regdata r0r1r2r3 uses r0|r1|r2|r3|r0r1|r2r3 compatible r32;
regdata r4r5r6r7 uses r4|r5|r6|r7|r4r5|r6r7 compatible r32;

register param;
regdata param;

// --- Core things ----------------------------------------------------------

gen STARTFILE();
gen ENDFILE();

gen LABEL():b uses all
{
	E_label($b.label);
}

gen JUMP():j uses all
{
	E_jmp($j.label);
}

// --- Subroutines ----------------------------------------------------------

gen STARTSUB() uses all
{
    EmitterOpenStream(current_subr);

	E("\n\n\t; ");
	E(current_subr.name);
	E(" ws0 at ");
	E_b8(COO_ESCAPE_WSREF);
	E_b16(current_subr.id);
	E_b8(0);
	E_b16(0);
	E("+");
	E_b8(COO_ESCAPE_WSSIZE);
	E_b16(current_subr.id);
	E_b8(0);
	E_nl();

    E_b8(COO_ESCAPE_THISSUB);
    E(":\n");
}

gen ENDSUB() uses all
{
    E_insn_simple("ret");

    EmitterCloseStream();
}

gen CALL(param, SUBREF()):s
    { E_insn("jsr"); E_subref($s.subr); E_nl(); }
gen CALL(param, r0r1):s
    { E_callhelper("__indirectcall"); }

gen param := END();
gen param := ARG1(param, r8:r):a;
gen param := ARG2(param, r16:r):a;
gen param := ARG4(param, r32:r):a;

gen r8 := POPARG1():a { }
gen r16 := POPARG2():a { }
gen r32 := POPARG4():a { }

gen RETURN() uses all
{
    E_insn_simple("ret");
}

// --- Simple things --------------------------------------------------------

gen r16|dptr := ADDRESS():a
{
	var cache := RegCacheFindAddress(&$a.sym, $a.off) & $$;
	if (cache & $$) != 0 then
		# The value is already in the desired register.
		return;
	end if;

	if $$ == REG_DPTR then
        E_insn("mov dptr,#");
        E_symref(&$a.sym, $a.off);
	else
        E_insn("mov");
        E_reghi($$);
        E(",#<");
        E_symref(&$a.sym, $a.off);
        E_nl();

        E_insn("mov");
        E_reglo($$);
        E(",#>");
        E_symref(&$a.sym, $a.off);
    end if;
    E_nl();

	RegCacheLeavesAddress($$, &$a.sym, $a.off);
}

gen r16 := CONSTANT():c
{
	var cache := RegCacheFindConstant($c.value as uint16) & $$;
	if (cache & $$) != 0 then
		# The value is already in the desired register.
		return;
	end if;

    E_insn("mov");
    E_reghi($$);
    E(",#<");
    E_u16($c.value as uint16);
    E_nl();

    E_insn("mov");
    E_reglo($$);
    E(",#>");
    E_u16($c.value as uint16);
    E_nl();

	RegCacheLeavesConstant($$, $c.value as uint16);
}

gen r8|a := CONSTANT():c
{
	var cache := RegCacheFindConstant($c.value as uint16) & $$;
	if (cache & $$) != 0 then
		# The value is already in the desired register.
		return;
	end if;

    E_insn("mov");
    E_reg($$);
    E(",#");
    E_u8($c.value as uint8);
    E_nl();

	RegCacheLeavesConstant($$, $c.value as uint16);
}

gen r32 := CONSTANT():c
{
    var v := $c.value;

    E_insn("mov");
    E_reglo(reglo($$));
    E(",#");
    E_u8(v as uint8);
    E_nl();
    v := v >> 8;

    E_insn("mov");
    E_reghi(reglo($$));
    E(",#");
    E_u8(v as uint8);
    E_nl();
    v := v >> 8;

    E_insn("mov");
    E_reglo(reghi($$));
    E(",#");
    E_u8(v as uint8);
    E_nl();
    v := v >> 8;

    E_insn("mov");
    E_reghi(reghi($$));
    E(",#");
    E_u8(v as uint8);
    E_nl();
}

//
//gen d|x := SUBREF():s
//{
//    R_flush($$);
//    E_ld($$);
//    E_const();
//    E_subref($s.subr);
//    E_nl();
//}

// --- Loads and stores -----------------------------------------------------

gen r8 := DEREF1(r16:rhs)
    { E_insn("mov16b"); E_reg($$); E_comma(); E_regi($rhs); E_nl(); }

gen r8 := DEREF1(r16:rhs)
    { E_insn("movb16"); E_reg($$); E_comma(); E_regi($rhs); E_nl(); }

gen r16 := DEREF2(r16:rhs)
    { E_insn("mov16"); E_reg($$); E_comma(); E_regi($rhs); E_nl(); }

gen r32 := DEREF4(r16:rhs)
    {
        E_insn("mov16");
        E_reghi($$);
        E_comma();
        E_regi($rhs);
        E_nl();

        E_insn("inc216");
        E_reg($rhs);
        E_nl();

        E_insn("mov16");
        E_reglo($$);
        E_comma();
        E_regi($rhs);
        E_nl();

        RegCacheApplyDelta($rhs, 2);
    }

gen STORE2(r16:lhs, DEREF2(r16:rhs))
    { E_insn("mov"); E_regi($rhs); E_comma(); E_reg($lhs); E_nl(); }

gen STORE2(DEREF2(r16:lhs), DEREF2(r16:rhs))
    { E_insn("mov"); E_regi($rhs); E_comma(); E_regi($lhs); E_nl(); }

gen STORE1(r8:lhs, DEREF1(r16:rhs))
    { E_insn("mov16b"); E_regi($rhs); E_comma(); E_reg($lhs); E_nl(); }

gen STORE4(r32:lhs, DEREF4(r16:rhs))
    {
        E_insn("mov16");
        E_regi($rhs);
        E_comma();
        E_reghi($lhs);
        E_nl();

        E_insn("inc216");
        E_reg($rhs);
        E_nl();

        E_insn("mov16");
        E_regi($rhs);
        E_comma();
        E_reglo($lhs);
        E_nl();

        RegCacheApplyDelta($rhs, 2);
    }

// --- 8-bit arithmetic -----------------------------------------------------

gen a := ADD1(a, CONSTANT(value==1):c)
    { E_insn_simple("inc a"); }

gen a := ADD1(a, CONSTANT():c)
    { E_insn("add a,#"); E_u8($c.value as uint8); E_nl(); }

gen a := ADD1(a, r8:rhs)
    { E_insn("add a,"); E_reg($rhs); E_nl(); }

gen a := SUB1(a, r8:rhs)
    { E_insn_simple("clr c"); E_insn("subb a,"); E_reg($rhs); E_nl(); }

gen a := OR1(a, r8:rhs)
    { E_insn("orl a,"); E_reg($rhs); E_nl(); }

gen a := AND1(a, r8:rhs)
    { E_insn("anl a,"); E_reg($rhs); E_nl(); }

gen a := EOR1(a, r8:rhs)
    { E_insn("xrl a,"); E_reg($rhs); E_nl(); }

gen a := RSHIFTU1(a, r0)
    { E_callhelper("__lsr1"); }

gen a := RSHIFTS1(a, r0)
    { E_callhelper("__asr1"); }

gen a := LSHIFT1(a, r0)
    { E_callhelper("__lsr1"); }

// --- 16-bit arithmetic ----------------------------------------------------

gen r16 := ADD2(r16:lhs, $$:rhs)
    { E_insn("add16"); E_reg($$); E_comma(); E_reg($lhs); E_nl(); }

gen r16 := ADD2(DEREF2(r16:lhs), $$:rhs)
    { E_insn("add16"); E_reg($$); E_comma(); E_regi($lhs); E_nl(); }

gen r16 := ADD2($$:lhs, CONSTANT(value==1))
    { E_insn("inc16"); E_reg($$); E_nl(); }

gen r16 := ADD2($$:lhs, CONSTANT(value==2))
    { E_insn("inc216"); E_reg($$); E_nl(); }

gen r16 := SUB2($$:lhs, r16:rhs)
    { E_insn("sub16"); E_reg($$); E_comma(); E_reg($rhs); E_nl(); }

gen r16 := AND2(r16:lhs, $$:rhs)
    { E_insn("anl16"); E_reg($$); E_comma(); E_reg($lhs); E_nl(); }

gen r16 := OR2(r16:lhs, $$:rhs)
    { E_insn("orl16"); E_reg($$); E_comma(); E_reg($lhs); E_nl(); }

gen r16 := EOR2(r16:lhs, $$:rhs)
    { E_insn("xrl16"); E_reg($$); E_comma(); E_reg($lhs); E_nl(); }

gen r16 := NOT2(r16:lhs) uses a
{
    E_insn_simple("mov a, #0xff");
    E_mov8(reglo($$), REG_A);
    E_mov8(reghi($$), REG_A);

    E_insn("xrl16");
    E_reg($$);
    E_comma();
    E_reg($lhs);
    E_nl();
}

gen r16 := NEG2(r16:lhs) uses a
{
    E_insn_simple("clr a");
    E_mov8(reglo($$), REG_A);
    E_mov8(reghi($$), REG_A);

    E_insn("sub16");
    E_reg($$);
    E_comma();
    E_reg($lhs);
    E_nl();
}

gen r16 := LSHIFT2($$:lhs, a)
    { E_insn("lsl16"); E_reg($lhs); E(",a\n"); }

gen r16 := RSHIFTU2($$:lhs, a)
    { E_insn("lsr16"); E_reg($lhs); E(",a\n"); }

gen r16 := RSHIFTS2($$:lhs, a)
    { E_insn("asr16"); E_reg($lhs); E(",a\n"); }

gen r0r1 := DIVU2(r0r1:lhs, r2r3:rhs)
    { E_callhelper("__divremu2"); }

gen r2r3 := REMU2(r0r1:lhs, r2r3:rhs)
    { E_callhelper("__divremu2"); }

gen r0r1 := DIVS2(r0r1:lhs, r2r3:rhs)
    { E_callhelper("__divrems2"); }

gen r2r3 := REMS2(r0r1:lhs, r2r3:rhs)
    { E_callhelper("__divrems2"); }

// --- 32-bit arithmetic ----------------------------------------------------

gen r0r1r2r3 := MUL4(r0r1r2r3, r4r5r6r7)
    { E_callhelper("__mul4"); }

gen r0r1r2r3 := DIVU4(r0r1r2r3, r4r5r6r7)
    { E_callhelper("__divremu4"); }

gen r4r5r6r7 := REMU4(r0r1r2r3, r4r5r6r7)
    { E_callhelper("__divremu4"); }

gen $$ := ADD4(r32:lhs, $$)
{
    E_insn("add16");
    E_reglo($$);
    E_comma();
    E_reglo($lhs);
    E_nl();

    E_insn("addc16");
    E_reghi($$);
    E_comma();
    E_reghi($lhs);
    E_nl();
}

gen $$ := SUB4($$, r32:rhs)
{
    E_insn("sub16");
    E_reglo($$);
    E_comma();
    E_reglo($rhs);
    E_nl();

    E_insn("subb16");
    E_reghi($$);
    E_comma();
    E_reghi($rhs);
    E_nl();
}

gen r4r5r6r7 := NEG4(r0r1r2r3:rhs) uses a
    { E_callhelper("__neg4"); }

gen r0r1r2r3 := RSHIFTU4($$:lhs, a)
    { E_callhelper("__lsr4"); }

gen r0r1r2r3 := RSHIFTS4($$:lhs, a)
    { E_callhelper("__asr4"); }

gen r0r1r2r3 := LSHIFT4($$:lhs, a)
    { E_callhelper("__lsl4"); }

// --- Casts ----------------------------------------------------------------

gen r16 := CAST12(r8:rhs, sext==0) uses a
{
    R_flush($$);

    E_mov8(reglo($$), $rhs);

    E_insn("mov");
    E_reghi($$);
    E(",#0");
}

gen r32 := CAST14(r8:rhs, sext==0) uses a
{
    R_flush($$);

    E_mov8(reglo(reglo($$)), $rhs);

    E_insn_simple("clr a");
    E_mov8(reghi(reglo($$)), REG_A);
    E_mov8(reglo(reghi($$)), REG_A);
    E_mov8(reghi(reghi($$)), REG_A);
}

gen r32 := CAST24(r16:rhs, sext==0) uses a
{
    R_flush($$);

    E_mov16(reglo($$), $rhs);

    E_insn_simple("clr a");
    E_mov8(reglo(reghi($$)), REG_A);
    E_mov8(reghi(reghi($$)), REG_A);
}

gen r8 := CAST21(r16:rhs)
{
    R_flush($$);

    E_mov8($$, reglo($rhs));
}

gen r8 := CAST41(r32:rhs)
{
    R_flush($$);

    E_mov8($$, reglo(reglo($rhs)));
}

gen r16 := CAST42(r32:rhs)
{
    R_flush($$);

    E_mov16($$, reglo($rhs));
}

// --- Conditionals ---------------------------------------------------------

gen BEQ0(CONSTANT():lhs, CONSTANT():rhs):b uses all
{
    var label := $b.falselabel;
    if $lhs.value == $rhs.value then
        label := $b.truelabel;
    end if;
    if label != $b.fallthrough then
        E_jmp(label);
    end if;
}

%{
    sub Cmp2(lhs: RegId, rhs: RegId) is
        E_insn("cmp16");
        E_reg(lhs);
        E_comma();
        E_reg(rhs);
        E_nl();
    end sub;
%}

gen BEQ1(r8:lhs, a:rhs):b uses all
{
    E_insn_simple("clr c");
    E_insn("subb a,");
    E_reg($lhs);
    E_nl();

    E_jumps_with_fallthrough("jz", "jnz", $@$);
}

gen BLTU1(a:lhs, r8:rhs):b uses all
{
    E_insn_simple("clr c");
    E_insn("subb a,");
    E_reg($rhs);
    E_nl();

    E_jumps_with_fallthrough("jnc", "jc", $@$);
}

gen BEQ2(r16:lhs, r16:rhs):b uses all
{
    Cmp2($lhs, $rhs);

    E_insn("jb UD,");
    E_labelref($b.truelabel);
    E_nl();

    if $b.falselabel != $b.fallthrough then
        E_insn("jmp");
        E_labelref($b.falselabel);
        E_nl();
    end if;
}

gen BLTU2(r16:lhs, r16:rhs):b uses all
{
    E_insn("sub16");
    E_reg($lhs);
    E_comma();
    E_reg($rhs);
    E_nl();

    E_jumps_with_fallthrough("jc", "jnc", $@$);
}

gen BLTS2(r0r1:lhs, r2r3:rhs):b uses all
{
    E_callhelper("__cmp2s");
    E_jumps_with_fallthrough("jc", "jnc", $@$);
}

gen BLTU4(r0r1r2r3, r4r5r6r7):b uses all
{
    E_callhelper("__cmp32u");
    E_jumps_with_fallthrough("jc", "jnc", $@$);
}

gen BLTS4(r0r1r2r3, r4r5r6r7):b uses all
{
    E_callhelper("__cmp32s");
    E_jumps_with_fallthrough("jc", "jnc", $@$);
}

gen BEQ4(r0r1r2r3, r4r5r6r7):b uses all
{
    E_callhelper("__cmp32z");
    E_jumps_with_fallthrough("jz", "jnz", $@$);
}

// --- Case -----------------------------------------------------------------

gen STARTCASE1(a) uses all;
gen STARTCASE2(r0r1) uses all;
gen STARTCASE4(r0r1r2r3) uses all;

gen WHENCASE1():c
{
    E_insn("cjne a,#");
    E_u8($c.value as uint8);
    E_comma();
    E_labelref($c.falselabel);
    E_nl();
}

//gen WHENCASE2():c uses all
//{
//    E_insn("cpx");
//    E_const();
//    E_u16($c.value as uint16);
//    E_nl();
//    E_insn("bne");
//    E_labelref($c.falselabel);
//    E_nl();
//}
//
//gen WHENCASE4():c uses all
//{
//    E_insn("cpx");
//    E_const();
//    E_u16(($c.value >> 16) as uint16);
//    E_nl();
//    E_insn("bne");
//    E_labelref($c.falselabel);
//    E_nl();
//
//    E_xgdx();
//    E_insn("cpx");
//    E_const();
//    E_u16($c.value as uint16);
//    E_nl();
//    E_xgdx();
//    E_insn("bne");
//    E_labelref($c.falselabel);
//    E_nl();
//}

gen ENDCASE1();
gen ENDCASE2();
gen ENDCASE4();

// --- Strings --------------------------------------------------------------

%{
    sub E_string(data: string): (lid: uint16) is
        lid := AllocPLabel();

        EmitterOpenStream(current_subr);

        E_label(lid);
        E_db();

        loop
            var c := [data];
            if c == 0 then
                break;
            end if;
            data := data + 1;
            
            E_u8(c);
            E_comma();
        end loop;
        E("0\n");
        EmitterCloseStream();
    end sub;
%}

gen r16 := STRING():s
{
	var lid := E_string($s.text);
	R_flush($$);

    E_insn("mov");
    E_reglo($$);
    E_comma();
    E("#<");
    E_labelref(lid);
    E_nl();

    E_insn("mov");
    E_reghi($$);
    E_comma();
    E("#>");
    E_labelref(lid);
    E_nl();
}

// --- Initialisers ---------------------------------------------------------

gen STARTINIT():s
{
    EmitterOpenStream(current_subr);
	E_symref(&$s.sym, 0);
    E(":\n");
}

gen ENDINIT()
{
    EmitterCloseStream();
}

gen INIT1():c
{
    E_db();
    E_u8($c.value as uint8);
    E_nl();
}

gen INIT2():c
{
    E_dw();
    E_u16($c.value as uint16);
    E_nl();
}

gen INIT4():c
{
    E_dw();
    E_u16(($c.value as uint32 >> 16) as uint16);
    E_comma();
    E_u16($c.value as uint16);
    E_nl();
}

gen INITADDRESS():a
{
    E_dw();
	E_symref(&$a.sym, $a.off);
    E_nl();
}

gen INITSUBREF():a
{
    E_dw();
	E_subref($a.subr);
    E_nl();
}

gen INITSTRING():s
{
    var sid := E_string($s.text);

    E_dw();
    E_labelref(sid);
    E_nl();
}

// --- Inline assembly ------------------------------------------------------

gen ASMGROUPSTART() uses all;
gen ASMGROUPEND();

gen ASMSTART()
{
    E_tab();
}

gen ASMTEXT():t
{
    E($t.text);
    E_space();
}

gen ASMSYMBOL():s
{
	E_symref(&$s.sym, 0);
    E_space();
}

gen ASMSUBREF():s
{
	E_subref($s.subr);
    E_space();
}

gen ASMVALUE():c
{
    E_openp();
    E_i32($c.value);
    E_closep();
}

gen ASMEND()
{
    E_nl();
}

// vim: sw=4 ts=4 et

